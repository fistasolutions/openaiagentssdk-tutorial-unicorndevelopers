# ğŸ“¦ New Items Processing with OpenAI Agents SDK

## ğŸ“š Overview

This tutorial demonstrates how to work with new items generated by AI agents using the OpenAI Agents SDK. You'll learn how to access and process different types of items that agents create during execution, including message outputs, reasoning, and other structured data.

## ğŸ” Key Concepts Explained

### ğŸ“¦ What are New Items?

- **Structured Output**: Items represent different types of agent-generated content
- **Rich Data**: Contains messages, reasoning, and other structured information
- **Type System**: Different item types serve different purposes
- **Extraction Tools**: SDK provides helpers to extract specific data types

### ğŸ¯ Item Types

The SDK supports various item types:
- **message_output_item**: Standard text messages from the agent
- **reasoning_item**: Agent's internal reasoning process
- **tool_output_item**: Results from tool executions
- **error_item**: Error information from failed operations

### ğŸ”§ ItemHelpers

The `ItemHelpers` class provides utilities to:
- **Extract Text**: Get text content from message items
- **Process Reasoning**: Access agent reasoning data
- **Handle Types**: Work with different item types safely
- **Standardize Access**: Provide consistent interfaces

## ğŸ¯ What You'll Learn

- How to access and process new items from agent executions
- Using ItemHelpers for data extraction
- Understanding different item types
- Building applications that leverage structured agent output
- Working with agent reasoning and internal processes

## ğŸ”§ Prerequisites

- Python 3.7+ installed
- Basic understanding of Python programming
- Knowledge of agent basics (from previous tutorials)
- OpenAI API key
- Understanding of environment variables

## ğŸ“¦ Required Dependencies

```bash
pip install openai-agents python-dotenv
```

## ğŸ—ï¸ Project Structure

```
4newitem/
â”œâ”€â”€ 4newitem.py    # Main script file
â””â”€â”€ README.md      # This file
```

## ğŸ”‘ Environment Setup

Create a `.env` file in your project root with:

```env
OPENAI_API_KEY=your_openai_api_key_here
```

## ğŸ“– Code Explanation

### 1. Import Statements

```python
from agents import Agent, Runner, set_default_openai_key, ItemHelpers
from dotenv import load_dotenv
import os
```

**What each import does:**
- `Agent`: The main class for creating AI agents
- `Runner`: Utility class for running agents
- `set_default_openai_key`: Sets the default API key for the SDK
- `ItemHelpers`: Utility class for processing agent items
- `load_dotenv`: Loads environment variables from `.env` file
- `os`: For accessing environment variables

### 2. Environment Configuration

```python
load_dotenv()
set_default_openai_key(os.environ.get("OPENAI_API_KEY"))
```

**Step-by-step explanation:**
1. `load_dotenv()`: Reads the `.env` file and loads variables
2. `set_default_openai_key()`: Sets the API key for the SDK

### 3. Agent Creation

```python
agent = Agent(
    name="Assistant",
    instructions="Answer concisely. Share your reasoning."
)
```

**Agent Configuration:**
- `name`: "Assistant" - general-purpose agent
- `instructions`: Requests concise answers with reasoning
- This encourages the agent to generate reasoning items

### 4. Agent Execution

```python
result = Runner.run_sync(agent, "Explain gravity in simple words.")
```

**What happens here:**
1. Agent receives the question about gravity
2. Generates a response with reasoning
3. Creates various items during the process

### 5. Final Output Display

```python
# Print Final Output
print("ğŸ”¹ Final Output:\n", result.final_output)
print("\nğŸ§¾ New Items Generated:")
```

**Purpose:** Shows the main response and introduces item processing

### 6. Item Processing Loop

```python
# Loop through new_items
for item in result.new_items:
    print(f"\nâ–¶ï¸ Item Type: {item.type}")
    if item.type == "message_output_item":
        print("ğŸ’¬ Message:", ItemHelpers.text_message_output(item))
    elif item.type == "reasoning_item":
        print("ğŸ§  Reasoning:", item.raw_item.reasoning)
    else:
        print("ğŸ“¦ Raw Item Data:", item.raw_item)
```

**Item Processing Breakdown:**
- `for item in result.new_items`: Iterates through all generated items
- `item.type`: Identifies the type of each item
- **message_output_item**: Uses `ItemHelpers.text_message_output()` to extract text
- **reasoning_item**: Accesses the reasoning data directly
- **Other types**: Shows raw item data for unknown types

## ğŸš€ How to Run

1. **Navigate to the directory:**
   ```bash
   cd 4newitem
   ```

2. **Set up your environment:**
   - Create a `.env` file with your OpenAI API key
   - Install dependencies: `pip install openai-agents python-dotenv`

3. **Run the script:**
   ```bash
   uv run 4newitem.py
   ```

## ğŸ“ Expected Output

```
ğŸ”¹ Final Output:
 Gravity is a force that pulls objects toward each other, like how Earth pulls you down.

ğŸ§¾ New Items Generated:

â–¶ï¸ Item Type: message_output_item
ğŸ’¬ Message: Gravity is a force that pulls objects toward each other, like how Earth pulls you down.

â–¶ï¸ Item Type: reasoning_item
ğŸ§  Reasoning: The user asked for a simple explanation of gravity. I should provide a clear, easy-to-understand definition that avoids complex physics terminology...
```

## ğŸ› ï¸ Customization Ideas

1. **Item type analyzer:**
   ```python
   def analyze_items(result):
       item_counts = {}
       for item in result.new_items:
           item_type = item.type
           item_counts[item_type] = item_counts.get(item_type, 0) + 1
       
       print("Item Analysis:")
       for item_type, count in item_counts.items():
           print(f"- {item_type}: {count} items")
   ```

2. **Reasoning extractor:**
   ```python
   def extract_reasoning(result):
       reasoning_items = []
       for item in result.new_items:
           if item.type == "reasoning_item":
               reasoning_items.append(item.raw_item.reasoning)
       return reasoning_items
   ```

3. **Message processor:**
   ```python
   def process_messages(result):
       messages = []
       for item in result.new_items:
           if item.type == "message_output_item":
               message = ItemHelpers.text_message_output(item)
               messages.append(message)
       return messages
   ```

## ğŸ“¦ Item Types Deep Dive

### message_output_item
- **Purpose:** Standard text messages from the agent
- **Access:** Use `ItemHelpers.text_message_output(item)`
- **Content:** The actual response text

### reasoning_item
- **Purpose:** Agent's internal reasoning process
- **Access:** Use `item.raw_item.reasoning`
- **Content:** Step-by-step reasoning behind the response

### tool_output_item
- **Purpose:** Results from tool executions
- **Access:** Use `item.raw_item.output`
- **Content:** Output from tools used by the agent

### error_item
- **Purpose:** Error information from failed operations
- **Access:** Use `item.raw_item.error`
- **Content:** Error details and stack traces

## ğŸ”§ ItemHelpers Methods

### text_message_output(item)
```python
# Extract text from message items
message = ItemHelpers.text_message_output(item)
```

### get_item_type(item)
```python
# Get the type of an item
item_type = ItemHelpers.get_item_type(item)
```

### is_message_item(item)
```python
# Check if item is a message
if ItemHelpers.is_message_item(item):
    # Process as message
```

### is_reasoning_item(item)
```python
# Check if item contains reasoning
if ItemHelpers.is_reasoning_item(item):
    # Process reasoning
```

## ğŸ“¦ Building Advanced Item Processing

### Item Processor Class

```python
class ItemProcessor:
    def __init__(self):
        self.processors = {
            "message_output_item": self.process_message,
            "reasoning_item": self.process_reasoning,
            "tool_output_item": self.process_tool_output,
            "error_item": self.process_error
        }
    
    def process_items(self, result):
        """Process all items in a result"""
        processed_data = {
            "messages": [],
            "reasoning": [],
            "tool_outputs": [],
            "errors": []
        }
        
        for item in result.new_items:
            processor = self.processors.get(item.type, self.process_unknown)
            data = processor(item)
            if data:
                processed_data[item.type].append(data)
        
        return processed_data
    
    def process_message(self, item):
        return ItemHelpers.text_message_output(item)
    
    def process_reasoning(self, item):
        return item.raw_item.reasoning
    
    def process_tool_output(self, item):
        return item.raw_item.output
    
    def process_error(self, item):
        return item.raw_item.error
    
    def process_unknown(self, item):
        return f"Unknown item type: {item.type}"
```

### Item Filtering

```python
def filter_items_by_type(result, item_type):
    """Filter items by type"""
    return [item for item in result.new_items if item.type == item_type]

def get_reasoning_items(result):
    """Get all reasoning items"""
    return filter_items_by_type(result, "reasoning_item")

def get_message_items(result):
    """Get all message items"""
    return filter_items_by_type(result, "message_output_item")
```

### Item Analytics

```python
def analyze_item_patterns(result):
    """Analyze patterns in generated items"""
    analysis = {
        "total_items": len(result.new_items),
        "item_types": {},
        "has_reasoning": False,
        "has_errors": False
    }
    
    for item in result.new_items:
        # Count item types
        item_type = item.type
        analysis["item_types"][item_type] = analysis["item_types"].get(item_type, 0) + 1
        
        # Check for specific types
        if item_type == "reasoning_item":
            analysis["has_reasoning"] = True
        elif item_type == "error_item":
            analysis["has_errors"] = True
    
    return analysis
```

## ğŸ“¦ When to Use New Items Processing

### âœ… **Use new items processing when:**
- Building applications that need detailed agent output
- Implementing reasoning transparency
- Debugging agent behavior
- Extracting structured data from responses
- Building analytics and monitoring systems

### âŒ **Don't use new items processing when:**
- Simple applications that only need final output
- Performance-critical systems
- Basic Q&A applications
- When you don't need detailed agent internals

## âš ï¸ Common Issues & Solutions

### Issue: "Item type not found"
**Solution:** Check the SDK version and use proper type checking

### Issue: "ItemHelpers method not working"
**Solution:** Ensure you're using the correct method for the item type

### Issue: "Empty new_items list"
**Solution:** This is normal for simple agent executions

### Issue: "ModuleNotFoundError: No module named 'agents'"
**Solution:** Install the SDK: `pip install openai-agents`

## ğŸ”— Related Topics

- [RunResult Properties](../1results/)
- [Input and Next Steps](../2inputnext/)
- [Final Agent Management](../3finalagent/)
- [Streaming Responses](../../11runningagents/3runasyncstreaming/)
- [Exception Handling](../../11runningagents/7exception/)

## ğŸ“š Additional Resources

- [OpenAI Agents SDK Documentation](https://github.com/openai/openai-agents)
- [Python Data Processing](https://pandas.pydata.org/docs/)
- [Structured Data in Python](https://docs.python.org/3/library/json.html)

## ğŸ‰ Next Steps

Once you understand new items processing, try:
1. Building item analysis tools
2. Creating reasoning transparency systems
3. Implementing item-based analytics
4. Building structured data extraction pipelines

---

**Happy Coding! ğŸš€**

*This tutorial is part of the OpenAI Agents SDK learning series.* 